# download_team_logos.py
import csv
import os
import requests
import time
import logging
from io import BytesIO
from PIL import Image, UnidentifiedImageError

# Assuming this script is in betting-bot/utils/ or similar, adjust path to root
# Or ensure your PYTHONPATH includes the betting-bot directory
try:
    from config.asset_paths import SPORT_CATEGORIES, DEFAULT_FALLBACK_CATEGORY
    from config.leagues import LEAGUE_IDS # Contains league name to sport mapping
    from config.team_mappings import normalize_team_name # For sanitizing team names
except ImportError:
    print("Error: Could not import from config package. Make sure this script is run from the 'betting-bot' directory or your PYTHONPATH is set correctly.")
    exit()

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# --- Configuration ---
CSV_FILE_PATH = "betting-bot/static/team_logos.csv"  # Path to the CSV file generated by the previous script
# Assuming BASE_DIR is the 'betting-bot' directory
BASE_DIR = os.path.dirname(os.path.abspath(__file__)) # If script is in betting-bot/
if os.path.basename(BASE_DIR) == 'utils': # If script is in betting-bot/utils/
    BASE_DIR = os.path.dirname(BASE_DIR)

STATIC_DIR = os.path.join(BASE_DIR, "static")
SAVE_BASE_PATH = os.path.join(STATIC_DIR, "logos", "teams")
REQUEST_DELAY_SECONDS = 0.5  # Delay between download attempts
DOWNLOAD_TIMEOUT_SECONDS = 15

# Helper to get sport category for path (simplified from your asset_paths)
def get_sport_folder_name(sport_name: str) -> str:
    """Determines a consistent folder name for the sport."""
    sport_name_upper = sport_name.upper()
    for category, leagues_in_cat in SPORT_CATEGORIES.items():
        # This mapping is a bit indirect. We need to see if the sport_name
        # itself is a category or if it belongs to one.
        if sport_name_upper == category:
            return category.upper() # e.g., "SOCCER", "FOOTBALL"
        # A more direct mapping from sport_name to folder_name might be needed
        # For now, let's use a simplified approach.
        # A direct map from "American Football" -> "FOOTBALL" would be better.
    # Fallback based on common sport names to categories
    if "FOOTBALL" in sport_name_upper and "AMERICAN" in sport_name_upper:
        return "FOOTBALL"
    if "SOCCER" in sport_name_upper:
        return "SOCCER"
    if "BASKETBALL" in sport_name_upper:
        return "BASKETBALL"
    if "BASEBALL" in sport_name_upper:
        return "BASEBALL"
    if "HOCKEY" in sport_name_upper:
        return "HOCKEY"
    if "MOTORSPORT" in sport_name_upper:
        return "RACING" # Align with your SPORT_CATEGORIES
    if "FIGHTING" in sport_name_upper:
        return "FIGHTING"
    # Add more specific mappings as needed based on your SPORT_CATEGORIES
    logger.warning(f"Could not determine a standard sport folder for '{sport_name}'. Using '{DEFAULT_FALLBACK_CATEGORY}'.")
    return DEFAULT_FALLBACK_CATEGORY.upper()

def get_league_code(league_name_from_csv: str) -> str:
    """Gets a short code for the league to use in file paths."""
    for code, details in LEAGUE_IDS.items():
        if details["name"].lower() == league_name_from_csv.lower():
            return code # Return the key like "NFL", "EPL"
    # Fallback: sanitize the league name itself
    return "".join(filter(str.isalnum, league_name_from_csv)).upper()


def download_and_save_image(league_name: str, team_name: str, logo_url: str):
    """
    Downloads an image from logo_url and saves it to the appropriate
    folder structure based on league and team name.
    """
    if not logo_url or not isinstance(logo_url, str) or not logo_url.startswith(('http://', 'https://')):
        logger.warning(f"Skipping team '{team_name}' in league '{league_name}': Invalid or missing logo URL ('{logo_url}').")
        return

    try:
        # Determine sport and league code for path construction
        current_league_sport = "OTHER_SPORTS" # Default
        league_code_for_path = league_name.upper().replace(" ", "_") # Default

        for l_code, l_details in LEAGUE_IDS.items():
            if l_details["name"].lower() == league_name.lower():
                current_league_sport = l_details["sport"]
                league_code_for_path = l_code # Use the key like "NFL", "EPL"
                break
        
        sport_folder = get_sport_folder_name(current_league_sport)
        
        # Sanitize team name for filename using your existing function
        sanitized_team_name = normalize_team_name(team_name)
        if not sanitized_team_name:
            logger.error(f"Could not generate a valid filename for team '{team_name}'. Skipping.")
            return

        # Construct save path: static/logos/teams/SPORT_CATEGORY/LEAGUE_CODE/team_name_sanitized.png
        # Example: static/logos/teams/FOOTBALL/NFL/arizona_cardinals.png
        # Example: static/logos/teams/SOCCER/EPL/arsenal.png
        
        # Handle NCAA separately for subfolders if desired (as in your load_logos.py)
        if league_code_for_path.startswith("NCAA"):
            # You might have NCAA Football, NCAA Basketball etc.
            # The 'sport_folder' derived from LEAGUE_IDS should handle this.
            # e.g. if league_code_for_path = "NCAAF", sport_folder becomes "FOOTBALL"
            # Path: static/logos/teams/SPORT_CATEGORY_FROM_NCAA_TYPE/NCAAF_OR_NCAAB_CODE/
            # The current `get_sport_folder_name` will use the sport from LEAGUE_IDS.
            # The `league_code_for_path` will be the key from LEAGUE_IDS (e.g., "NFL", or your NCAA key).
            # This means for NCAA, if your LEAGUE_IDS has "NCAAF": {"sport": "American Football"},
            # sport_folder = "FOOTBALL", league_code_for_path = "NCAAF"
            # path = SAVE_BASE_PATH / FOOTBALL / NCAAF / team_name.png
            # This seems reasonable.
             pass


        team_logo_dir = os.path.join(SAVE_BASE_PATH, sport_folder, league_code_for_path)
        os.makedirs(team_logo_dir, exist_ok=True)
        
        file_extension = ".png" # Save all as PNG for consistency
        file_name = f"{sanitized_team_name}{file_extension}"
        full_save_path = os.path.join(team_logo_dir, file_name)

        if os.path.exists(full_save_path):
            logger.info(f"Logo already exists for {team_name} at {full_save_path}. Skipping download.")
            return

        logger.info(f"Downloading logo for '{team_name}' from '{logo_url}' to '{full_save_path}'")
        
        response = requests.get(logo_url, stream=True, timeout=DOWNLOAD_TIMEOUT_SECONDS)
        response.raise_for_status() # Raise an exception for bad status codes

        # Process with Pillow to ensure format and potentially resize
        try:
            img_bytes = BytesIO(response.content)
            with Image.open(img_bytes) as img:
                if img.mode != 'RGBA':
                    img = img.convert('RGBA')
                # Optional: Resize if needed, e.g., img.thumbnail((200,200), Image.Resampling.LANCZOS)
                img.save(full_save_path, 'PNG', optimize=True)
            logger.info(f"Successfully saved logo for {team_name} to {full_save_path}")

        except UnidentifiedImageError:
            logger.error(f"Cannot identify image file from URL for {team_name}: {logo_url}")
        except Exception as e_img:
            logger.error(f"Error processing image for {team_name} from {logo_url}: {e_img}")

        time.sleep(REQUEST_DELAY_SECONDS) # Be polite to servers

    except requests.exceptions.RequestException as e:
        logger.error(f"Error downloading logo for {team_name} from {logo_url}: {e}")
    except IOError as e:
        logger.error(f"Error saving file for {team_name} to {full_save_path}: {e}")
    except Exception as e:
        logger.error(f"An unexpected error occurred for team {team_name}, URL {logo_url}: {e}")


def main():
    if not os.path.exists(CSV_FILE_PATH):
        logger.error(f"CSV file not found: {CSV_FILE_PATH}")
        return

    # Ensure base save directory exists
    os.makedirs(SAVE_BASE_PATH, exist_ok=True)
    logger.info(f"Base save path for team logos: {SAVE_BASE_PATH}")

    processed_count = 0
    with open(CSV_FILE_PATH, 'r', newline='', encoding='utf-8') as csvfile:
        reader = csv.DictReader(csvfile)
        if not reader.fieldnames or not all(f in reader.fieldnames for f in ['league_name', 'team_name', 'logo_url']):
            logger.error("CSV file is missing required columns: 'league_name', 'team_name', 'logo_url'")
            return

        for row in reader:
            league_name = row.get('league_name')
            team_name = row.get('team_name')
            logo_url = row.get('logo_url')

            if league_name and team_name and logo_url:
                download_and_save_image(league_name, team_name, logo_url)
                processed_count +=1
            else:
                logger.warning(f"Skipping row due to missing data: {row}")
    
    logger.info(f"Finished processing {processed_count} entries from {CSV_FILE_PATH}.")

if __name__ == "__main__":
    main()
